# -*- coding: utf-8 -*-
"""GA_Ackley function.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16Ckip0VgOJOJTlA2WKW8NmeVW2f99qFN
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import random
import math
import matplotlib.pyplot as plt
from tqdm.notebook import tqdm
import warnings

np.set_printoptions(suppress=True)
# %matplotlib inline
warnings.filterwarnings("ignore")

class GA:
    def __init__(self,Num=30,Dimension=5,Bitnum=4,Elite_num=3,CrossoverR=0.9,MutationR=0.2,Max_Iteration=1000):
        self.N=Num  #數量
        self.D=Dimension
        self.B=Bitnum
        self.n=Elite_num #菁英
        self.cr=CrossoverR #交配率
        self.mr=MutationR #突變率
        self.max_iter=Max_Iteration

    def generatePopulation(self):
        population=[] #族群設定空的
        for number in range(self.N):
            chrom_list=[] #基因設為空的
            for run in range(self.D):
                elemt=(np.zeros((1,self.B))).astype(int)
                for i in range(1):
                    for j in range(self.B):
                        elemt[i,j]=np.random.randint(0,2) #0,1隨機編排
                Chromosome=list(elemt[0])
                chrom_list.append(Chromosome) #放入列表中
            population.append(chrom_list) #再將基因放入族群
        return population #並回傳族群

    def BitToDec(self,pop):
        dec=str(pop[0])+str(pop[1])+str(pop[2])+str(pop[3]) #因bitnum設為4
        return int(str(dec),2)

    def DecToBit(self,num):
        return [int(i) for i in (bin(10)[2:])]

    # Ackley function
    def fun(self,pop):
        X=np.array(pop)
        fun_sum=0
        sum1=0
        sum2=0
        term1=0
        term2=0
        for i in range(self.D):
            x=X[:,i]
            sum1+=x**2
            sum2+=np.cos(2*np.pi*x)
        term1=-20*np.exp(-0.2*np.sqrt(sum1/self.D))
        term2=-np.exp(sum2/self.D)
        fun_sum=term1+term2+20+np.exp(1)
        return list(fun_sum)

    # 選擇 菁英挑選法
    def Selection(self,n,pop_bin,fitness):
        select_bin=pop_bin.copy() #選擇的bin
        fitness1=fitness.copy()
        Parents=[]
        #最佳的情形 直接選入parent
        if sum(fitness1)==0:
            for i in range(self.n):
                parent=select_bin[random.randint(0,(self.N)-1)]
                Parents.append(parent)
        else:
            for i in range(4):
                #挑選之中較佳的
                arr = fitness1.index(min(fitness1))
                Parents.append(select_bin[arr])
                del select_bin[arr]
                del fitness1[arr]
        return Parents

    # 交配突變
    def Crossover_Mutation(self,parent1,parent2):
        #將兩元素交換位置(單點交配)
        def swap_machine(elemt1,elemt2):
            temp=elemt1
            elemt1=elemt2
            elemt2=temp
            return elemt1,elemt2
        child1=[]
        child2=[]
        for i in range(len(parent1)):
            #0~1之間利用random隨機生成數字，決定是否交配(跟交配率比)
            z1=random.uniform(0,1)
            if z1<self.cr:
                z2 =random.uniform(0,1)
                #決定要交換的位置點
                cross_location=math.ceil(z2*(len(parent1[i])-1))
                #進行交配
                parent1[i][:cross_location],parent2[i][:cross_location]=swap_machine(parent1[i][:cross_location],parent2[i][:cross_location])
                p_list=[parent1[i],parent2[i]]
                #隨機生成一數字，用以決定是否進行mutation
                for i in range(len(p_list)):
                    z3=random.uniform(0,1)
                    if z3<self.mr:
                        #決定要mutate的數字
                        z4=random.uniform(0,1)
                        temp_location=z4*(len(p_list[i])-1)
                        mutation_location=0 if temp_location < 0.5 else math.ceil(temp_location)
                        p_list[i][mutation_location]=0 if p_list[i][mutation_location] == 1 else 1
                child1.append(p_list[0])
                child2.append(p_list[1])
            else:
                child1.append(parent1[i])
                child2.append(parent2[i])
        return child1,child2

def main():
    ga=GA()
    print("數量:",ga.N)
    print("維度:",ga.D)
    print("bit數:",ga.B)
    pop_bin=ga.generatePopulation()
    pop_dec=[]
    for i in range(ga.N):
        chrom_rv=[]
        for j in range(ga.D):
            chrom_rv.append(ga.BitToDec(pop_bin[i][j])) #轉十進位
        pop_dec.append(chrom_rv) #放入群集中
    fitness=ga.fun(pop_dec) #計算fitness值

    best_fitness=min(fitness)
    arr=fitness.index(best_fitness)
    best_dec=pop_dec[arr]

    best_rvlist=[]
    best_valuelist=[]

    it=0
    while it<ga.max_iter:
        Parents_list=ga.Selection(ga.n,pop_bin,fitness)#菁英挑選
        Offspring_list=[] #子代設定
        for i in range(int((ga.N-ga.n)/2)):
            candidate=[Parents_list[random.randint(0,len(Parents_list)-1)] for i in range(2)]
            after_cr_mu=ga.Crossover_Mutation(candidate[0], candidate[1])
            offspring1,offspring2=after_cr_mu[0],after_cr_mu[1]
            Offspring_list.append(offspring1)
            Offspring_list.append(offspring2)

        final_bin=Parents_list+Offspring_list
        final_dec=[]
        for i in range(ga.N):
            rv=[]
            for j in range(ga.D):
                rv.append(ga.BitToDec(final_bin[i][j]))
            final_dec.append(rv)

        #fitness值
        final_fitness=ga.fun(final_dec)

        #拿取迭代中最佳的值(越小則越佳，故使用min)
        smallest_fitness=min(final_fitness)
        index=final_fitness.index(smallest_fitness)
        smallest_dec=final_dec[index]

        #儲存最佳fitness至列表
        best_rvlist.append(smallest_dec)
        best_valuelist.append(smallest_fitness)

        #參數回到初始值
        pop_bin=final_bin
        pop_dec=final_dec
        fitness=final_fitness
        it += 1

    #儲存最佳解
    every_best_value=[]
    every_best_value.append(best_valuelist[0])
    for i in range(ga.max_iter-1):
        if every_best_value[i]>=best_valuelist[i+1]:
            every_best_value.append(best_valuelist[i+1])

        elif every_best_value[i]<=best_valuelist[i+1]:
            every_best_value.append(every_best_value[i])

    print('The best fitness: ',min(best_valuelist))
    best_index=best_valuelist.index(min(best_valuelist))
    print('Setup list is: ')
    print(best_rvlist[best_index])
    #圖形
    plt.figure(figsize=(15,8))
    plt.xlabel("Iteration",fontsize=15)
    plt.ylabel("Fitness",fontsize=15)

    plt.plot(every_best_value,linewidth=2,label="Best fitness convergence",color='r')
    plt.legend()
    plt.show()

if __name__ == '__main__':
    main()